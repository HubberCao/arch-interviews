## 线程

### 线程之间是如何通信的

1.通过线程之间共享变量的方式
		(1) synchronized + Object的 wait(),notify(),以及notifyAll() 
		(2) 使用lock.newCondition().await() 和 signal() 方法实现线程之间交互 
		(3) 利用volatile
2. 通过队列(BlockingQueue)来实现线程的通信

		用java.util.concurrent包中linkedBlockingQueue 来进行线程间交互； 
		java.util.concurrent.LinkedBlockingQueue 是一个基于单向链表的、范围任意的（其实是有界的）、FIFO 阻塞队列。
		访问与移除操作是在队头进行，添加操作是在队尾进行，并分别使用不同的锁进行保护，只有在可能涉及多个节点的操作才同时对两个锁进行加锁。
3. 套接字（Socket），不同的机器之间进行通信

```
java线程间通信：

1：线程上下文
2：共享内存
3：IPC通信
4：套接字（Socket），不同的机器之间进行通信

linux常用的进程间的通讯方式
（1）、管道(pipe)：管道可用于具有亲缘关系的进程间的通信，是一种半双工的方式，数据只能单向流动，允许一个进程和另一个与它有共同祖先的进程之间进行通信。
（2）、命名管道(named pipe)：命名管道克服了管道没有名字的限制，同时除了具有管道的功能外（也是半双工），它还允许无亲缘关系进程间的通信。命名管道在文件系统中有对应的文件名。命名管道通过命令mkfifo或系统调用mkfifo来创建。
（3）、信号（signal）：信号是比较复杂的通信方式，用于通知接收进程有某种事件发生了，除了进程间通信外，进程还可以发送信号给进程本身；linux除了支持Unix早期信号语义函数sigal外，还支持语义符合Posix.1标准的信号函数sigaction（实际上，该函数是基于BSD的，BSD为了实现可靠信号机制，又能够统一对外接口，用sigaction函数重新实现了signal函数）。
（4）、消息队列：消息队列是消息的链接表，包括Posix消息队列system V消息队列。有足够权限的进程可以向队列中添加消息，被赋予读权限的进程则可以读走队列中的消息。消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺
（5）、共享内存：使得多个进程可以访问同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。往往与其它通信机制，如信号量结合使用，来达到进程间的同步及互斥。
（6）、内存映射：内存映射允许任何多个进程间通信，每一个使用该机制的进程通过把一个共享的文件映射到自己的进程地址空间来实现它。
（7）、信号量（semaphore）：主要作为进程间以及同一进程不同线程之间的同步手段。
（8）、套接字（Socket）：更为一般的进程间通信机制，可用于不同机器之间的进程间通信。起初是由Unix系统的BSD分支开发出来的，但现在一般可以移植到其它类Unix系统上：Linux和System V的变种都支持套接字。
```

## ReentrantLock

### 是如何实现可重入性的？

```
为每个锁关联一个获取计数器和一个所有者线程,当计数值为0的时候,这个所就没有被任何线程只有.当线程请求一个未被持有的锁时,
JVM将记下锁的持有者,并且将获取计数值置为1,如果同一个线程再次获取这个锁,技术值将递增,退出一次同步代码块,计算值递减,
当计数值为0时,这个锁就被释放.ReentrantLock里面有实现
```
- [可重入锁ReentrantLock详解](https://www.iteye.com/blog/donald-draper-2360411)
- [Java可重入锁学习笔记](https://www.shiyanlou.com/questions/2460/)
